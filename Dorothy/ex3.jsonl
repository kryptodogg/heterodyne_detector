{
  "instruction": "Explain how to implement MVDR beamforming on GPU with PyTorch.",
  "input": "",
  "output": "MVDR (Minimum Variance Distortionless Response) beamforming on GPU with PyTorch:\n\n```python\n# Input: rx_signals (num_antennas, num_samples) - complex GPU tensor\n# Steering vector for desired direction: steering_vec (num_antennas,) - complex GPU tensor\n\ndef mvdr_beamform(rx_signals, steering_vec):\n    # Compute covariance matrix: R = X @ X^H / N\n    N = rx_signals.shape[1]\n    covariance = torch.mm(rx_signals, rx_signals.conj().transpose(-1, -2)) / N\n    \n    # Add regularization to avoid singular matrix\n    reg = 1e-6 * torch.eye(covariance.shape[0], dtype=covariance.dtype, device=covariance.device)\n    covariance = covariance + reg\n    \n    # Compute inverse: R^(-1)\n    cov_inv = torch.linalg.inv(covariance)\n    \n    # Compute numerator: R^(-1) * a\n    numerator = torch.mv(cov_inv, steering_vec)\n    \n    # Compute denominator: a^H * R^(-1) * a\n    denominator = torch.vdot(steering_vec.conj(), numerator)\n    \n    # Compute MVDR weights: w = R^(-1) * a / (a^H * R^(-1) * a)\n    weights = numerator / denominator\n    \n    # Apply beamforming: y = w^H * X\n    beamformed = torch.vdot(weights.conj(), rx_signals)\n    \n    return beamformed\n```\n\nThis implementation keeps all operations on GPU tensors and leverages PyTorch's optimized linear algebra operations."
}
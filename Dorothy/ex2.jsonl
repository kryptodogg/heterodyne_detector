{
  "instruction": "How to implement range-Doppler processing with PyTorch for GPU acceleration?",
  "input": "",
  "output": "Range-Doppler processing with PyTorch for GPU acceleration:\n\n```python\nimport torch\nimport numpy as np\n\nclass RangeDopplerProcessor(torch.nn.Module):\n    def __init__(self, config, device='cuda'):\n        super().__init__()\n        self.device = device\n        \n        # Configuration parameters\n        self.range_fft_size = config.get('range_fft_size', 1024)\n        self.doppler_fft_size = config.get('doppler_fft_size', 256)\n        self.num_pulses = config.get('num_pulses', 128)\n        \n        # Pre-compute windows for efficiency\n        self.range_window = torch.hann_window(self.range_fft_size, device=device)\n        self.doppler_window = torch.hann_window(self.doppler_fft_size, device=device)\n        \n        # Pre-allocate output tensor\n        self.rd_map = torch.zeros((self.doppler_fft_size, self.range_fft_size), \n                                dtype=torch.complex64, device=device)\n    \n    def forward(self, signal_matrix):\n        '''\n        signal_matrix: (num_pulses, num_samples) - complex tensor\n        Returns: (doppler_bins, range_bins) - range-Doppler map\n        '''\n        # Ensure input is on correct device\n        signal_matrix = signal_matrix.to(self.device)\n        \n        # Range FFT (fast-time) - across samples within each pulse\n        # Apply window to reduce sidelobes\n        windowed_signal = signal_matrix * self.range_window\n        \n        # Perform range FFT\n        range_fft = torch.fft.fft(windowed_signal, n=self.range_fft_size, dim=1)\n        \n        # Doppler FFT (slow-time) - across pulses at each range bin\n        # Apply window to reduce Doppler sidelobes\n        range_fft_windowed = range_fft.t() * self.doppler_window  # Transpose for Doppler processing\n        doppler_fft = torch.fft.fft(range_fft_windowed, n=self.doppler_fft_size, dim=1).t()  # Transpose back\n        \n        # Apply FFT shift to center zero frequency/velocity\n        rd_map = torch.fft.fftshift(torch.fft.fftshift(doppler_fft, dim=0), dim=1)\n        \n        return rd_map\n    \n    def process(self, signal_matrix):\n        '''Process signal matrix to range-Doppler map.'''\n        return self.forward(signal_matrix)\n```\n\nThis implementation performs efficient 2D FFT processing on GPU to create range-Doppler maps for target detection and velocity estimation."
}